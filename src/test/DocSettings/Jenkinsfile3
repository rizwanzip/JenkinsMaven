@Library('centapplib@SnD_R_1.1') _

def taggit = false

def SnDApps = "SnD UI\nCentegy Map\nCentegy Integrator UI\nCentegy SSO"
def SnDModules = ""

pipeline {
    agent any

    parameters {
            string(defaultValue: env.VERSION, description: 'What Version?', name: 'VERSION')
            //string(defaultValue: env.INCLUDE_PROJECTS, description: 'Project to include (CSV format)?', name: 'INCLUDE_PROJECTS')
            choice(name: 'SND_APP', choices: "${SnDApps}", description: 'App to build?')
            booleanParam(defaultValue: false, description: 'Check to use previous incremental history, this option is useful only when last build got failed after build event.', name: 'USE_INCREMENTAL_HISOTRY')
            booleanParam(defaultValue: false, description: 'Release should be deployed to QA?', name: 'DEPLOY_TO_QA')
            string(defaultValue: env.QA_DEPLOY_DIR, description: 'QA Deploy Location?', name: 'QA_DEPLOY_DIR')
     }

    stages {
        stage('Select Modules') {
            when {
		        expression { env.SND_APP != null }
            }
            steps {
                echo 'Selecting modules..'
                script {
                	util.info("Select Modules from groovy")    
                	
                	SnDModules = util.getModules(env.SND_APP)

                	env.SND_MODS = input message: 'Please enter the modules to build ', ok: 'Proceed!',
                        parameters: [text(name: 'SND_MODS', defaultValue: "${SnDModules}", description: 'Modules to build?')]
                          
			        SnDModules = env.SND_MODS

                   	txtfile.write("${env.WORKSPACE}/mods/${env.SND_APP}", SnDModules);
                }
            }
        }
        stage('Pre Build') {            
            when {
		        expression { env.VERSION != null }
            }
            steps {
                echo 'Pre Building..'
                script{
                    mypipeline.init(env.VERSION, env.USE_INCREMENTAL_HISOTRY, SnDModules)
                }
            }
        }
        stage('Build') {
            when {
		        expression { env.VERSION != null }
            }
            steps {
                echo 'Building..'
                script{
                    mypipeline.build(env.VERSION, SnDModules)
                    //mypipeline.updateJar(env.VERSION)
                }
            }
            post {
                always {
                    echo 'Sending build summary..'
                    script{
                        mypipeline.notifyBuild();
                    }
                }
            }
        }
//        stage('Test') {
//            steps {
//                echo 'Testing..'
//                script{
//                    mypipeline.test(env.VERSION)
//                }
//            }
//            post {
//                always {
//                    echo 'Sending test summary email..'
//                    script{
//                        mypipeline.notifyTestSuccess();
//                    }
//                }
//            }
//        }
        stage('Release') {
            when {
		        expression { env.VERSION != null }
            }
            steps {
                echo 'Deploying....'
                script{
                    mypipeline.publish(env.VERSION, SnDModules)
                    
                    mypipeline.updateJar(env.VERSION);	
                }
            }
            post {
                failure {
                    echo 'Sending release failure email..'
                    script{
                        mypipeline.notifyPlain();
                    }
                }
            }
        }
        stage('Obfuscate') {
            when {
		        expression { env.VERSION != null }
            }
            steps {
                echo 'Obfuscating....'
                script{
                    mypipeline.prepareObfuscate(env.VERSION)
                    mypipeline.modifyObfusConfig(env.VERSION)
                    mypipeline.obfuscate(env.VERSION)
                    
                    taggit = true
                }
            }
            post {
                failure {
                    echo 'Sending obfuscation failure email..'
                    script{
                        mypipeline.notifyPlain();
                    }
                }
            }            
        }
//        stage('Deploy Approval') {
//            steps {
//                input 'Deploy for release?'
//            }
//        }
		stage('Finalize') {
		    parallel {
		        
		            stage('Deploy') {
		            when {
		                expression { env.VERSION != null }
		            }
		            steps {
		                echo 'Deploying....'
		                script{
		                    mypipeline.deploy(env.VERSION, env.DEPLOY_TO_QA, env.QA_DEPLOY_DIR)
		                }
		            }
		            post {
		                failure {
		                    echo 'Sending deploy failure email..'
		                    script{
		                        mypipeline.notifyPlain();
		                    }
		                }
		            }               
		        }
		        
		        stage('GitTag') {
					when {
						expression { taggit == true }
					}
		            steps {
		                echo 'Tagging the release....'
		                script{
		                    mypipeline.gitTag(env.VERSION)
		                }
		            }
		            post {
		                failure {
		                    echo 'Sending GitTag failure email..'
		                    script{
		                        mypipeline.notifyPlain();
		                    }
		                }
		            }               
		        }		        
		    }
		}
    }
}